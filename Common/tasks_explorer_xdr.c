/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "tasks_explorer.h"

bool_t
xdr_tasks_list(xdrs, objp)
	XDR *xdrs;
	tasks_list *objp;
{

	if (!xdr_array(xdrs, (char **)&objp->tasks_list_val, (u_int *)&objp->tasks_list_len, MAX_TASKS, sizeof(int), (xdrproc_t)xdr_int))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_command_line(xdrs, objp)
	XDR *xdrs;
	command_line *objp;
{

	if (!xdr_string(xdrs, objp, MAX_PARAMS_LEN))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_app_descr(xdrs, objp)
	XDR *xdrs;
	app_descr *objp;
{

	if (!xdr_string(xdrs, objp, MAX_APP_DESCR))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_env_type(xdrs, objp)
	XDR *xdrs;
	env_type *objp;
{

	if (!xdr_string(xdrs, objp, MAX_ENV_RECORD))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_env_list(xdrs, objp)
	XDR *xdrs;
	env_list *objp;
{

	if (!xdr_pointer(xdrs, (char **)objp, sizeof(struct env_node), (xdrproc_t)xdr_env_node))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_env_node(xdrs, objp)
	XDR *xdrs;
	env_node *objp;
{

	if (!xdr_env_type(xdrs, &objp->name))
		return (FALSE);
	if (!xdr_env_list(xdrs, &objp->next))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_file_name(xdrs, objp)
	XDR *xdrs;
	file_name *objp;
{

	if (!xdr_string(xdrs, objp, MAX_PATH))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_files_list(xdrs, objp)
	XDR *xdrs;
	files_list *objp;
{

	if (!xdr_pointer(xdrs, (char **)objp, sizeof(struct files_list_node), (xdrproc_t)xdr_files_list_node))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_files_list_node(xdrs, objp)
	XDR *xdrs;
	files_list_node *objp;
{

	if (!xdr_file_name(xdrs, &objp->name))
		return (FALSE);
	if (!xdr_files_list(xdrs, &objp->next))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_host_info_dynamic(xdrs, objp)
	XDR *xdrs;
	host_info_dynamic *objp;
{

	if (!xdr_u_int(xdrs, &objp->cpu_kernel))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->cpu_user))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_task_info_base(xdrs, objp)
	XDR *xdrs;
	task_info_base *objp;
{

	if (!xdr_u_int(xdrs, &objp->pid))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->ppid))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->name, 64, sizeof(char), (xdrproc_t)xdr_char))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->user, 64, sizeof(char), (xdrproc_t)xdr_char))
		return (FALSE);
	if (!xdr_u_int(xdrs, &objp->cputype))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->path_to_boundle, MAX_PATH, sizeof(char), (xdrproc_t)xdr_char))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->path_to_executable, MAX_PATH, sizeof(char), (xdrproc_t)xdr_char))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->path_to_icon, MAX_PATH, sizeof(char), (xdrproc_t)xdr_char))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->bundle_ver, 64, sizeof(char), (xdrproc_t)xdr_char))
		return (FALSE);
	if (!xdr_vector(xdrs, (char *)objp->bundle_copyright, 1024, sizeof(char), (xdrproc_t)xdr_char))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_task_info_base_t(xdrs, objp)
	XDR *xdrs;
	task_info_base_t *objp;
{

	if (!xdr_task_info_base(xdrs, objp))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_task_info_dynamic(xdrs, objp)
	XDR *xdrs;
	task_info_dynamic *objp;
{
	int32_t *buf;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = (int32_t *)XDR_INLINE(xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_u_int(xdrs, &objp->threads))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->ports))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->real_mem_size))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->virtual_mem_size))
				return (FALSE);
		} else {
			IXDR_PUT_U_LONG(buf, objp->threads);
			IXDR_PUT_U_LONG(buf, objp->ports);
			IXDR_PUT_U_LONG(buf, objp->real_mem_size);
			IXDR_PUT_U_LONG(buf, objp->virtual_mem_size);
		}
		if (!xdr_float(xdrs, &objp->cpu_usage_total))
			return (FALSE);
		if (!xdr_float(xdrs, &objp->cpu_usage_user))
			return (FALSE);
		if (!xdr_float(xdrs, &objp->cpu_usage_kernel))
			return (FALSE);
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = (int32_t *)XDR_INLINE(xdrs, 4 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_u_int(xdrs, &objp->threads))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->ports))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->real_mem_size))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->virtual_mem_size))
				return (FALSE);
		} else {
			objp->threads = IXDR_GET_U_LONG(buf);
			objp->ports = IXDR_GET_U_LONG(buf);
			objp->real_mem_size = IXDR_GET_U_LONG(buf);
			objp->virtual_mem_size = IXDR_GET_U_LONG(buf);
		}
		if (!xdr_float(xdrs, &objp->cpu_usage_total))
			return (FALSE);
		if (!xdr_float(xdrs, &objp->cpu_usage_user))
			return (FALSE);
		if (!xdr_float(xdrs, &objp->cpu_usage_kernel))
			return (FALSE);
	} else {
		if (!xdr_u_int(xdrs, &objp->threads))
			return (FALSE);
		if (!xdr_u_int(xdrs, &objp->ports))
			return (FALSE);
		if (!xdr_u_int(xdrs, &objp->real_mem_size))
			return (FALSE);
		if (!xdr_u_int(xdrs, &objp->virtual_mem_size))
			return (FALSE);
		if (!xdr_float(xdrs, &objp->cpu_usage_total))
			return (FALSE);
		if (!xdr_float(xdrs, &objp->cpu_usage_user))
			return (FALSE);
		if (!xdr_float(xdrs, &objp->cpu_usage_kernel))
			return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_thread_info_list(xdrs, objp)
	XDR *xdrs;
	thread_info_list *objp;
{

	if (!xdr_pointer(xdrs, (char **)objp, sizeof(struct thread_info_node), (xdrproc_t)xdr_thread_info_node))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_thread_info_node(xdrs, objp)
	XDR *xdrs;
	thread_info_node *objp;
{
	int32_t *buf;

	if (xdrs->x_op == XDR_ENCODE) {
		buf = (int32_t *)XDR_INLINE(xdrs, 6 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_u_int(xdrs, &objp->run_state))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->user_time))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->system_time))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->suspend_count))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->sleep_time))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->flags))
				return (FALSE);
		} else {
			IXDR_PUT_U_LONG(buf, objp->run_state);
			IXDR_PUT_U_LONG(buf, objp->user_time);
			IXDR_PUT_U_LONG(buf, objp->system_time);
			IXDR_PUT_U_LONG(buf, objp->suspend_count);
			IXDR_PUT_U_LONG(buf, objp->sleep_time);
			IXDR_PUT_U_LONG(buf, objp->flags);
		}
		if (!xdr_string(xdrs, &objp->entry_point_name, 1024))
			return (FALSE);
		if (!xdr_u_long(xdrs, &objp->thread_id))
			return (FALSE);
		if (!xdr_thread_info_list(xdrs, &objp->next))
			return (FALSE);
	} else if (xdrs->x_op == XDR_DECODE) {
		buf = (int32_t *)XDR_INLINE(xdrs, 6 * BYTES_PER_XDR_UNIT);
		if (buf == NULL) {
			if (!xdr_u_int(xdrs, &objp->run_state))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->user_time))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->system_time))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->suspend_count))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->sleep_time))
				return (FALSE);
			if (!xdr_u_int(xdrs, &objp->flags))
				return (FALSE);
		} else {
			objp->run_state = IXDR_GET_U_LONG(buf);
			objp->user_time = IXDR_GET_U_LONG(buf);
			objp->system_time = IXDR_GET_U_LONG(buf);
			objp->suspend_count = IXDR_GET_U_LONG(buf);
			objp->sleep_time = IXDR_GET_U_LONG(buf);
			objp->flags = IXDR_GET_U_LONG(buf);
		}
		if (!xdr_string(xdrs, &objp->entry_point_name, 1024))
			return (FALSE);
		if (!xdr_u_long(xdrs, &objp->thread_id))
			return (FALSE);
		if (!xdr_thread_info_list(xdrs, &objp->next))
			return (FALSE);
	} else {
		if (!xdr_u_int(xdrs, &objp->run_state))
			return (FALSE);
		if (!xdr_u_int(xdrs, &objp->user_time))
			return (FALSE);
		if (!xdr_u_int(xdrs, &objp->system_time))
			return (FALSE);
		if (!xdr_u_int(xdrs, &objp->suspend_count))
			return (FALSE);
		if (!xdr_u_int(xdrs, &objp->sleep_time))
			return (FALSE);
		if (!xdr_u_int(xdrs, &objp->flags))
			return (FALSE);
		if (!xdr_string(xdrs, &objp->entry_point_name, 1024))
			return (FALSE);
		if (!xdr_u_long(xdrs, &objp->thread_id))
			return (FALSE);
		if (!xdr_thread_info_list(xdrs, &objp->next))
			return (FALSE);
	}
	return (TRUE);
}

bool_t
xdr_stack_info_list(xdrs, objp)
	XDR *xdrs;
	stack_info_list *objp;
{

	if (!xdr_pointer(xdrs, (char **)objp, sizeof(struct stack_info_node), (xdrproc_t)xdr_stack_info_node))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_stack_info_node(xdrs, objp)
	XDR *xdrs;
	stack_info_node *objp;
{

	if (!xdr_u_long(xdrs, &objp->return_addr))
		return (FALSE);
	if (!xdr_u_long(xdrs, &objp->frame_addr))
		return (FALSE);
	if (!xdr_string(xdrs, &objp->func_name, 1024))
		return (FALSE);
	if (!xdr_stack_info_list(xdrs, &objp->next))
		return (FALSE);
	return (TRUE);
}

bool_t
xdr_call_stack_request(xdrs, objp)
	XDR *xdrs;
	call_stack_request *objp;
{

	if (!xdr_u_int(xdrs, &objp->pid))
		return (FALSE);
	if (!xdr_u_long(xdrs, &objp->tid))
		return (FALSE);
	return (TRUE);
}
