/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "tasks_explorer.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

int *
task_explorer_init_1(argp, clnt)
	void *argp;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, TASK_EXPLORER_INIT, xdr_void, argp, xdr_int, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

int *
task_explorer_free_1(argp, clnt)
	void *argp;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, TASK_EXPLORER_FREE, xdr_void, argp, xdr_int, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

host_info_dynamic *
task_explorer_update_1(argp, clnt)
	void *argp;
	CLIENT *clnt;
{
	static host_info_dynamic clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, TASK_EXPLORER_UPDATE, xdr_void, argp, xdr_host_info_dynamic, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

tasks_list *
task_explorer_tasks_list_1(argp, clnt)
	void *argp;
	CLIENT *clnt;
{
	static tasks_list clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, TASK_EXPLORER_TASKS_LIST, xdr_void, argp, xdr_tasks_list, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

task_info_base *
task_explorer_base_info_1(argp, clnt)
	int *argp;
	CLIENT *clnt;
{
	static task_info_base clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, TASK_EXPLORER_BASE_INFO, xdr_int, argp, xdr_task_info_base, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

command_line *
task_explorer_params_1(argp, clnt)
	int *argp;
	CLIENT *clnt;
{
	static command_line clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, TASK_EXPLORER_PARAMS, xdr_int, argp, xdr_command_line, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

int *
kill_process_1(argp, clnt)
	int *argp;
	CLIENT *clnt;
{
	static int clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, KILL_PROCESS, xdr_int, argp, xdr_int, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

env_list *
task_explorer_env_list_1(argp, clnt)
	int *argp;
	CLIENT *clnt;
{
	static env_list clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, TASK_EXPLORER_ENV_LIST, xdr_int, argp, xdr_env_list, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

task_info_dynamic *
task_explorer_dyninfo_1(argp, clnt)
	int *argp;
	CLIENT *clnt;
{
	static task_info_dynamic clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, TASK_EXPLORER_DYNINFO, xdr_int, argp, xdr_task_info_dynamic, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

files_list *
task_explorer_files_list_1(argp, clnt)
	int *argp;
	CLIENT *clnt;
{
	static files_list clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, TASK_EXPLORER_FILES_LIST, xdr_int, argp, xdr_files_list, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

app_descr *
task_explorer_app_descr_1(argp, clnt)
	int *argp;
	CLIENT *clnt;
{
	static app_descr clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, TASK_EXPLORER_APP_DESCR, xdr_int, argp, xdr_app_descr, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

thread_info_list *
task_explorer_threads_info_1(argp, clnt)
	int *argp;
	CLIENT *clnt;
{
	static thread_info_list clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, TASK_EXPLORER_THREADS_INFO, xdr_int, argp, xdr_thread_info_list, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

stack_info_list *
task_explorer_stack_for_thread_1(argp, clnt)
	struct call_stack_request *argp;
	CLIENT *clnt;
{
	static stack_info_list clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, TASK_EXPLORER_STACK_FOR_THREAD, xdr_call_stack_request, argp, xdr_stack_info_list, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}
